<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat with Support</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        html, body {
            height: 100%;
        }
        body {
            background: linear-gradient(to right, #6a11cb, #2575fc);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center the chat container vertically */
            align-items: center; /* Center the chat container horizontally */
            color: #fff;
            padding: 10px; /* Padding around container on large screens */
            overflow: hidden; /* Prevent body scroll */
        }

        /* Chat Container */
        .chat-container {
            width: 90%;
            max-width: 500px;
            height: 90vh; /* Adjusted height for better screen fit */
            max-height: 750px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            /* Adjusted Padding: Increased bottom padding */
            padding: 20px 20px 30px 20px; /* Top | R | Bottom | L */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.18);
            overflow: hidden; /* Container itself doesn't scroll */
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #admin-status .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 5px;
            vertical-align: middle;
            background-color: #ccc; /* Default offline (Grey) */
            transition: background-color 0.3s ease;
        }
        #admin-status .status-dot.online { background-color: #33ff33; } /* Green */
        #admin-status .status-dot.offline { background-color: #ccc; } /* Grey */

        /* Messages Area */
        .messages {
            flex: 1; /* Takes up available vertical space */
            overflow-y: auto; /* Allows scrolling ONLY for messages */
            margin-bottom: 15px; /* Space below messages */
            padding-right: 5px;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        .messages::-webkit-scrollbar { width: 6px; }
        .messages::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; }
        .messages::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }

        /* Message Styling */
        .message-wrapper {
             display: flex; margin-bottom: 12px; max-width: 85%; position: relative;
        }
        .message-wrapper.sent { align-self: flex-end; justify-content: flex-end; }
        .message-wrapper.received { align-self: flex-start; }
        .message-wrapper.bot { align-self: flex-start; }
        .message-wrapper p {
            padding: 10px 15px; border-radius: 18px; word-wrap: break-word;
            background: rgba(255, 255, 255, 0.2); color: #fff; line-height: 1.45;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .message-wrapper.sent p { background-color: #00c6ff; color: #111; border-bottom-right-radius: 5px; }
        .message-wrapper.received p { background-color: #ffd700; color: #111; border-bottom-left-radius: 5px; }
        .message-wrapper.bot p { background-color: rgba(255, 255, 255, 0.8); color: #333; border-bottom-left-radius: 5px; }

        /* Timestamp Styling */
        .timestamp {
            font-size: 0.7em; color: rgba(255, 255, 255, 0.65); margin-top: 4px;
            padding: 0 5px; display: block;
        }
        .message-wrapper.sent .timestamp { text-align: right; }
        .message-wrapper.received .timestamp, .message-wrapper.bot .timestamp { text-align: left; }

        /* Typing Indicator */
        #typing-indicator {
            min-height: 18px; font-style: italic; color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em; margin-bottom: 10px; /* Increased space below indicator */
            padding-left: 5px; transition: opacity 0.3s ease; flex-shrink: 0;
        }

        /* Input Area */
        .input-container {
            display: flex; gap: 10px;
            /* margin-top: auto; Removed, let it flow naturally */
            padding-top: 5px; /* Reduced space above input */
            flex-shrink: 0; /* Prevent shrinking */
        }
        input[type="text"] {
            flex: 1; padding: 12px 15px; border: none; border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.9); color: #333; outline: none; font-size: 1em;
        }
        input[type="text"]::placeholder { color: #888; }
        input[type="text"]:disabled { background-color: #ddd; cursor: not-allowed; }

        /* Buttons */
        button {
            padding: 12px 18px; border: none; border-radius: 10px; background-color: #00ffcc;
            color: #000; cursor: pointer; font-weight: bold; transition: background-color 0.2s ease;
            font-size: 0.95em;
        }
        button:hover:not(:disabled) { background-color: #00ccaa; }
        button:disabled { background-color: #aaa; cursor: not-allowed; color: #eee; }

        /* Audio Call Button */
        .audio-call {
            margin-top: 15px; /* Increased space above call button */
            background-color: #ff4f81; color: white; width: 100%; flex-shrink: 0;
        }
        .audio-call:hover:not(:disabled) { background-color: #f03a6a; }

        /* Call Status */
        #call-status {
             margin-top: 10px; /* Increased space above call status */
             text-align: center; font-weight: bold; min-height: 20px;
             font-size: 0.9em; flex-shrink: 0;
        }

        /* Hidden Audio Element */
        #remoteAudio { display: none; }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            body { padding: 0; } /* Full screen on mobile */
            .chat-container {
                width: 100%;
                height: 100vh; /* Use full viewport height */
                max-height: 100vh; /* Ensure it doesn't exceed */
                border-radius: 0;
                /* Adjusted Padding for Mobile: More space at bottom */
                padding: 15px 15px 25px 15px; /* T | R | B | L */
            }
            .chat-header { font-size: 0.8em; padding-bottom: 8px; margin-bottom: 10px;}
            .message-wrapper { max-width: 90%; }
            input[type="text"] { padding: 10px 12px; font-size: 0.95em; }
            button { padding: 10px 15px; font-size: 0.9em; }
            .audio-call { padding: 10px; margin-top: 12px; } /* Adjusted margin */
            #call-status { margin-top: 8px; }
            #typing-indicator { margin-bottom: 8px; }
        }
    </style>
</head>
<body>

    <!-- Main Chat UI -->
    <div class="chat-container">
        <div class="chat-header">
             <span>Chat with Support</span>
             <div id="admin-status">Admin: <span class="status-dot offline" title="Offline"></span></div>
        </div>
        <div class="messages" id="messages">
             <!-- Messages appear here -->
        </div>
        <div id="typing-indicator"></div>
        <div class="input-container">
            <input type="text" id="messageInput" placeholder="Loading chat..." autocomplete="off" disabled/>
            <button id="sendButton" disabled>Send</button>
        </div>
        <button class="audio-call" id="audioCallButton" disabled>Start Audio Call</button>
        <div id="call-status"></div>
    </div>

    <!-- Audio element to play remote stream -->
    <audio id="remoteAudio" autoplay></audio>

    <!-- Firebase SDK -->
    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getDatabase, ref, push, set, onValue, onChildAdded, serverTimestamp, onDisconnect, query, orderByChild, limitToLast, off, update, remove, get } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js"; // Added 'get'

        // Firebase Configuration (Use your actual config)
        const firebaseConfig = {
            apiKey: "AIzaSyA5mBW5mXff46acu01BbPmZh8LGGXV42v8",
            authDomain: "chat-app-ddecb.firebaseapp.com",
            databaseURL: "https://chat-app-ddecb-default-rtdb.firebaseio.com",
            projectId: "chat-app-ddecb",
            storageBucket: "chat-app-ddecb.firebasestorage.app",
            messagingSenderId: "534760202357",
            appId: "1:534760202357:web:da7d90561af1c4220a183c",
            measurementId: "G-MCSSLKG71W"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const adminStatusDot = document.getElementById('admin-status').querySelector('.status-dot');
        const typingIndicatorDiv = document.getElementById('typing-indicator');
        const callButton = document.getElementById('audioCallButton');
        const callStatusDiv = document.getElementById('call-status');
        const remoteAudio = document.getElementById('remoteAudio');

        // --- State Variables ---
        let userId = localStorage.getItem('chatUserId');
        let userName = localStorage.getItem('chatUserName');
        let chatState = 'INITIALIZING'; // AWAITING_FIRST_MESSAGE -> AWAITING_NAME -> CHATTING
        let firstMessageSent = false;
        let chatRef, messagesRef, userStatusRef, userTypingRef, adminTypingRef, callRef, metadataRef, adminOnlineRef;
        let typingTimeout = null;
        let messageListener, adminStatusListener, adminTypingListener, callStateListener, callOfferListener, callAnswerListener, callAdminIceCandidateListener;

        // --- WebRTC State ---
        let peerConnection = null;
        let localStream = null;
        const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        let makingOffer = false;

        // --- Initialization ---
        function initApp() {
            console.log("Initializing App...");
            if (!userId) {
                userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
                localStorage.setItem('chatUserId', userId);
                console.log("Generated new userId:", userId);
            } else {
                console.log("Using existing userId:", userId);
            }

            // Define Firebase paths
            chatRef = ref(db, `chats/${userId}`);
            messagesRef = ref(db, `chats/${userId}/messages`);
            userStatusRef = ref(db, `chats/${userId}/status`);
            callRef = ref(db, `chats/${userId}/call`);
            userTypingRef = ref(db, `chats/${userId}/status/userTyping`);
            adminTypingRef = ref(db, `chats/${userId}/status/adminTyping`);
            metadataRef = ref(db, `chats/${userId}/metadata`);
            adminOnlineRef = ref(db, 'adminStatus/online');

            // Core event listeners
            sendButton.onclick = handleSendAction;
            messageInput.onkeydown = handleInputKeyDown;
            callButton.onclick = handleCallButtonClick;

            // Determine initial state
            userName = localStorage.getItem('chatUserName'); // Re-fetch in case it was set in another tab
            if (userName) {
                console.log(`Username '${userName}' found.`);
                chatState = 'CHATTING';
                firstMessageSent = true;
                enableChattingUI();
                startChatSession();
            } else {
                console.log("Username not found. Awaiting first message.");
                chatState = 'AWAITING_FIRST_MESSAGE';
                messageInput.disabled = false;
                sendButton.disabled = false;
                callButton.disabled = true;
                messageInput.placeholder = "Type a message to start...";
                // Clear any previous messages and show initial prompt
                messagesDiv.innerHTML = '<div class="message-wrapper bot"><p>Welcome! Type anything to begin.</p></div>';
                scrollToBottom();
            }

            requestNotificationPermission();
            listenToAdminStatus(); // Start listening immediately
        }

        // --- Name Handling (New Flow) ---
        function handleFirstMessage(messageText) {
            console.log("Handling first message from user.");
            firstMessageSent = true;
            // Display the user's first message optimistically
            displayMessage('sent', messageText, Date.now(), `local-${Date.now()}`);

            // Ask for the name
            displayMessage('bot', 'Thanks! To connect you, please tell me your name:');
            chatState = 'AWAITING_NAME';
            messageInput.placeholder = "Enter your name here...";
            messageInput.focus();
        }

        function handleNameSubmission(name) {
            if (!name) {
                displayMessage('bot', 'Name cannot be empty. Please tell me your name:');
                messageInput.placeholder = "Enter your name again...";
                return;
            }
            userName = name;
            localStorage.setItem('chatUserName', userName);
            chatState = 'CHATTING';
            console.log(`Username set to: ${userName}`);

            displayMessage('sent', name, Date.now(), `local-${Date.now()}-name`); // Show name entered
            displayMessage('bot', `Got it, ${userName}! You can now send messages or start a call.`);

            messageInput.value = '';
            messageInput.placeholder = "Type your message...";

            // Save metadata
            set(metadataRef, {
                userName: userName, userId: userId,
                firstSeen: serverTimestamp(), lastActive: serverTimestamp()
            }).then(() => {
                console.log("User metadata saved.");
                enableChattingUI();
                startChatSession();
            }).catch(error => {
                console.error("Error setting user metadata:", error);
                displayMessage('bot', "Error saving name. Please refresh.");
                disableChattingUI();
            });
        }

        // --- UI State Management ---
        function enableChattingUI() {
            console.log("Enabling full chat UI.");
            messageInput.disabled = false;
            sendButton.disabled = false;
            callButton.disabled = false;
            messageInput.placeholder = "Type your message...";
        }
        function disableChattingUI() {
             console.log("Disabling chat UI.");
             messageInput.disabled = true;
             sendButton.disabled = true;
             callButton.disabled = true;
        }

        // --- Firebase Session ---
        function startChatSession() {
            if (!userId || !userName) return;
            console.log("Starting Firebase listeners for chat session...");

            cleanupFirebaseListeners(false); // Keep admin status listener

            // Presence Management
            const userOnlineRef = ref(db, `chats/${userId}/status/userOnline`);
            const connectedRef = ref(db, '.info/connected');
            onValue(connectedRef, (snap) => {
                if (snap.val() === true) {
                    set(userOnlineRef, true);
                    update(metadataRef, { lastActive: serverTimestamp() });
                    onDisconnect(userOnlineRef).set(false);
                    onDisconnect(metadataRef).update({ lastActive: serverTimestamp() });
                }
            });

            // Listen for Messages
            const messagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(100));
            let initialLoadComplete = false;
            messageListener = onChildAdded(messagesQuery, (snapshot) => {
                 const msgId = snapshot.key;
                 const msg = snapshot.val();
                 const existingMsgEl = messagesDiv.querySelector(`.message-wrapper[data-msg-id="${msgId}"]`);
                 if (existingMsgEl) return; // Avoid duplicates

                 if (msg) {
                    displayMessage(msg.sender === 'user' ? 'sent' : (msg.sender === 'admin' ? 'received' : 'bot'), msg.text, msg.timestamp, msgId);
                    if (msg.sender === 'admin' && document.hidden) {
                        showNotification(`New message from Admin`);
                    }
                 }
                 if (initialLoadComplete) scrollToBottom();
            }, (error) => console.error("Message listener error:", error));
            onValue(messagesQuery, () => { // Scroll after initial history load
                if (!initialLoadComplete) { scrollToBottom(); initialLoadComplete = true; }
            }, { onlyOnce: true });

            // Listen for Admin Typing
            adminTypingListener = onValue(adminTypingRef, (snapshot) => {
                typingIndicatorDiv.textContent = snapshot.val() ? 'Admin is typing...' : '';
            }, (error) => console.error("Admin typing listener error:", error));

            // Listen for Call State & WebRTC Signaling
            listenForCallChanges();
        }

        // --- Firebase Listener Cleanup ---
         function cleanupFirebaseListeners(includeAdminStatus = true) {
             console.log("Cleaning up Firebase listeners...");
             if (messageListener) off(messagesRef, 'child_added', messageListener);
             if (includeAdminStatus && adminStatusListener) off(adminOnlineRef, 'value', adminStatusListener);
             if (adminTypingListener) off(adminTypingRef, 'value', adminTypingListener);
             if (callStateListener) off(ref(db, `chats/${userId}/call/state`), 'value', callStateListener);
             if (callOfferListener) off(ref(db, `chats/${userId}/call/offer`), 'value', callOfferListener);
             if (callAnswerListener) off(ref(db, `chats/${userId}/call/answer`), 'value', callAnswerListener);
             if (callAdminIceCandidateListener) off(ref(db, `chats/${userId}/call/adminIceCandidates`), 'child_added', callAdminIceCandidateListener);

             messageListener = null;
             if (includeAdminStatus) adminStatusListener = null;
             adminTypingListener = null; callStateListener = null; callOfferListener = null; callAnswerListener = null; callAdminIceCandidateListener = null;
         }


        // --- Core Actions ---
        function handleSendAction() {
            const messageText = messageInput.value.trim();
            if (!messageText && chatState !== 'AWAITING_FIRST_MESSAGE' && chatState !== 'AWAITING_NAME') return; // Allow empty for first msg/name prompt maybe? No, require text.

            if (chatState === 'AWAITING_FIRST_MESSAGE') {
                if (!messageText) return; // Require text for first message too
                handleFirstMessage(messageText);
                messageInput.value = '';
            } else if (chatState === 'AWAITING_NAME') {
                if (!messageText) { // Require name text
                     displayMessage('bot', 'Please enter your name.');
                     return;
                }
                handleNameSubmission(messageText);
                // Name submission clears input on success
            } else if (chatState === 'CHATTING') {
                if (!messageText) return; // Don't send empty chat messages
                sendChatMessage(messageText);
                messageInput.value = '';
            } else {
                console.warn("Send action in unexpected state:", chatState);
            }
        }

        function handleInputKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendAction();
            } else if (chatState === 'CHATTING') {
                handleUserTyping();
            }
        }

        function sendChatMessage(msgText) {
            if (!userId || !userName || !msgText) return;
            messageInput.focus();

            const messageData = {
                sender: 'user', text: msgText, timestamp: serverTimestamp(),
                userId: userId, userName: userName
            };
            push(messagesRef, messageData).then(() => {
                if (userTypingRef) set(userTypingRef, false);
                clearTimeout(typingTimeout);
                update(metadataRef, { lastActive: serverTimestamp() });
            }).catch(error => {
                 console.error("Error sending message: ", error);
                 displayMessage('bot', "Error: Message failed to send.");
            });
        }

        // --- Display & Scroll ---
        function displayMessage(senderType, text, timestamp, msgId = null) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('message-wrapper', senderType);
            if (msgId) wrapper.dataset.msgId = msgId;

            const p = document.createElement('p');
            p.textContent = text;
            wrapper.appendChild(p);

            const timeSpan = document.createElement('span');
            timeSpan.classList.add('timestamp');
            if (senderType !== 'bot' && timestamp) {
                 timeSpan.textContent = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                 timeSpan.textContent = '';
            }
            wrapper.appendChild(timeSpan);

            messagesDiv.appendChild(wrapper);
            // Scroll is handled by caller or listener usually
        }

        function scrollToBottom() {
            requestAnimationFrame(() => { messagesDiv.scrollTop = messagesDiv.scrollHeight; });
        }

        // --- Typing Indicator ---
        function handleUserTyping() {
            if (chatState !== 'CHATTING' || !userTypingRef) return;
            set(userTypingRef, true);
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => { set(userTypingRef, false); }, 2500);
        }

        // --- Admin Status Listener ---
        function listenToAdminStatus() {
             if (adminStatusListener) off(adminOnlineRef, 'value', adminStatusListener);
             adminStatusListener = onValue(adminOnlineRef, (snapshot) => {
                const isOnline = snapshot.val() === true || snapshot.val()?.online === true;
                console.log("Admin online status:", isOnline);
                adminStatusDot.classList.toggle('online', isOnline);
                adminStatusDot.classList.toggle('offline', !isOnline);
                adminStatusDot.title = isOnline ? 'Online' : 'Offline';
             }, (error) => console.error("Admin status listener error:", error));
        }


        // --- Audio Call & WebRTC ---

        function handleCallButtonClick() {
             if (callButton.textContent === 'Start Audio Call') {
                 startCallSequence();
             } else {
                 endCallSequence();
             }
         }

        async function startCallSequence() {
            if (chatState !== 'CHATTING' || !callRef || !userName) {
                displayMessage('bot', "Cannot start call until chat is active.");
                return;
            }
            console.log('Starting call sequence...');
            callButton.disabled = true;
            callStatusDiv.textContent = 'Requesting Mic...';

            // 1. Get Microphone
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                console.log("Microphone access granted.");
                callStatusDiv.textContent = 'Connecting...';
            } catch (error) {
                console.error("Error getting microphone:", error);
                callStatusDiv.textContent = 'Mic access denied!';
                displayMessage('bot', "Mic permission needed for calls.");
                callButton.disabled = false;
                return;
            }

            // 2. Create Peer Connection
            if (!createPeerConnection()) {
                callStatusDiv.textContent = 'Call setup failed.';
                endCallSequence(); return;
            }

            // 3. Add Local Track
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            console.log("Local audio track added.");

            // 4. Signal 'ringing' and Create/Send Offer
             try {
                makingOffer = true;
                await set(callRef, { // Reset call node with ringing state
                     state: 'ringing',
                     initiator: 'user',
                     timestamp: serverTimestamp(),
                     userName: userName,
                     offer: null, // Clear previous data
                     answer: null,
                     userIceCandidates: null,
                     adminIceCandidates: null
                 });
                 console.log("Call state 'ringing'. Creating offer...");

                 const offer = await peerConnection.createOffer();
                 await peerConnection.setLocalDescription(offer);
                 console.log("Offer created & set local.");

                 await set(ref(db, `chats/${userId}/call/offer`), { type: offer.type, sdp: offer.sdp });
                 console.log("Offer sent to Firebase.");

                 updateCallUIBasedOnState('ringing'); // UI Update

             } catch (error) {
                 console.error("Offer error:", error);
                 callStatusDiv.textContent = 'Call setup failed.';
                 displayMessage('bot', "Call setup error.");
                 endCallSequence();
             } finally {
                 makingOffer = false;
             }
        }

        function createPeerConnection() {
            console.log("Creating Peer Connection...");
             try {
                peerConnection = new RTCPeerConnection(iceServers);
                peerConnection.onicecandidate = handleIceCandidate;
                peerConnection.ontrack = handleRemoteTrack;
                peerConnection.oniceconnectionstatechange = handleIceConnectionStateChange;
                peerConnection.onconnectionstatechange = handleConnectionStateChange;
                 console.log("Peer Connection created.");
                 return true;
             } catch (error) {
                 console.error("PeerConnection creation failed:", error);
                 return false;
             }
        }

        function handleIceCandidate(event) {
            if (event.candidate) {
                console.log("Generated ICE candidate...");
                push(ref(db, `chats/${userId}/call/userIceCandidates`), event.candidate.toJSON())
                 .catch(e => console.error("Send ICE candidate error:", e));
            } else { console.log("All ICE candidates sent."); }
        }

        function handleRemoteTrack(event) {
            console.log("Remote track received:", event.track.kind);
            if (event.streams && event.streams[0] && remoteAudio) {
                 console.log("Assigning remote stream to audio element.");
                 remoteAudio.srcObject = event.streams[0];
                 remoteAudio.play().catch(e => console.warn("Remote audio play failed:", e));
            } else { console.warn("Could not assign remote stream."); }
        }

        function handleIceConnectionStateChange() {
            if (!peerConnection) return;
            console.log("ICE Connection State:", peerConnection.iceConnectionState);
            // Handle failed state if needed
            if (peerConnection.iceConnectionState === 'failed') {
                console.error("ICE Connection Failed.");
                displayMessage('bot', "Call connection failed (ICE).");
                endCallSequence();
            }
        }
         function handleConnectionStateChange() {
             if (!peerConnection) return;
             console.log("Connection State:", peerConnection.connectionState);
             switch (peerConnection.connectionState) {
                 case "connected": console.log("Peers connected!"); break;
                 case "disconnected": console.log("Peers disconnected."); break;
                 case "failed":
                     console.error("Connection failed.");
                     displayMessage('bot', "Call connection failed.");
                     endCallSequence(); break;
                 case "closed":
                     console.log("Connection closed.");
                     endCallSequence(); break; // Ensure cleanup on close
             }
         }

        function listenForCallChanges() {
             console.log("Setting up call listeners...");
             const stateRef = ref(db, `chats/${userId}/call/state`);
             const answerRef = ref(db, `chats/${userId}/call/answer`);
             const adminIceRef = ref(db, `chats/${userId}/call/adminIceCandidates`);
             const offerRef = ref(db, `chats/${userId}/call/offer`); // For admin initiation

             // Cleanup existing listeners first
             if (callStateListener) off(stateRef, 'value', callStateListener);
             if (callAnswerListener) off(answerRef, 'value', callAnswerListener);
             if (callAdminIceCandidateListener) off(adminIceRef, 'child_added', callAdminIceCandidateListener);
             if (callOfferListener) off(offerRef, 'value', callOfferListener);

             // 1. Listen for State Changes
             callStateListener = onValue(stateRef, (snapshot) => {
                 const newState = snapshot.val();
                 console.log("Call state changed to:", newState);
                 updateCallUIBasedOnState(newState);
                 if (newState === 'ended' || newState === 'idle' || !newState) {
                      if (peerConnection && peerConnection.connectionState !== "closed") {
                         console.log("Call ended remotely, cleaning up.");
                         closePeerConnection();
                         stopLocalStream();
                     }
                 }
             });

             // 2. Listen for Answer
             callAnswerListener = onValue(answerRef, async (snapshot) => {
                 const answer = snapshot.val();
                 if (peerConnection && peerConnection.signalingState === 'have-local-offer' && answer) {
                     console.log("Received answer.");
                     try {
                         await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                         console.log("Remote description (answer) set.");
                     } catch (error) { console.error("Error setting remote answer:", error); }
                 }
             });

             // 3. Listen for Admin ICE Candidates
             callAdminIceCandidateListener = onChildAdded(adminIceRef, (snapshot) => {
                 if (snapshot.exists()) {
                     const candidate = snapshot.val();
                     console.log("Received admin ICE candidate.");
                     if (peerConnection && peerConnection.remoteDescription) {
                         peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                             .then(() => console.log("Admin ICE candidate added."))
                             .catch(e => console.error("Error adding admin ICE candidate:", e));
                     } else { console.warn("Received admin ICE but PC not ready."); }
                     remove(snapshot.ref); // Clean up candidate after processing
                 }
             });

             // 4. Listen for Offer (Basic handling for admin initiation - needs more work for full feature)
             callOfferListener = onValue(offerRef, async (snapshot) => {
                 const offer = snapshot.val();
                 const callStateSnapshot = await get(ref(db, `chats/${userId}/call/state`)); // Get current state
                 const callState = callStateSnapshot.val();

                 if (!makingOffer && offer && callState === 'ringing' && peerConnection?.signalingState === 'stable') {
                     console.log("Received offer (Admin initiated?).");
                     displayMessage('bot', "Incoming call from Admin!");
                     // Basic UI update - full answer logic requires user interaction (accept/reject)
                     updateCallUIBasedOnState('ringing');
                     console.warn("Answering admin-initiated calls requires UI interaction (Accept/Reject) - not fully implemented.");
                     // TODO: Add Accept/Reject buttons and corresponding logic here.
                 }
             });
        }

        function closePeerConnection() {
            if (peerConnection) {
                console.log("Closing Peer Connection.");
                peerConnection.onicecandidate = null; peerConnection.ontrack = null;
                peerConnection.oniceconnectionstatechange = null; peerConnection.onconnectionstatechange = null;
                peerConnection.close();
                peerConnection = null;
            }
        }

        function stopLocalStream() {
            if (localStream) {
                console.log("Stopping local stream tracks.");
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if(remoteAudio) remoteAudio.srcObject = null;
        }

        async function endCallSequence() {
             console.log("Ending call sequence...");
             stopLocalStream();
             closePeerConnection();

              try {
                 const stateSnapshot = await get(ref(db, `chats/${userId}/call/state`));
                 if (stateSnapshot.exists() && stateSnapshot.val() !== 'ended' && stateSnapshot.val() !== 'idle') {
                     await update(callRef, { // Update only needed fields
                         state: 'ended',
                         endedBy: 'user',
                         endTimestamp: serverTimestamp()
                     });
                     console.log("Call state set to 'ended'.");
                     // Clean up signaling data
                     remove(ref(db, `chats/${userId}/call/offer`));
                     remove(ref(db, `chats/${userId}/call/answer`));
                     remove(ref(db, `chats/${userId}/call/userIceCandidates`));
                     remove(ref(db, `chats/${userId}/call/adminIceCandidates`));
                 } else { console.log("Call already ended/idle."); }
             } catch (error) { console.error("Error ending call in Firebase:", error); }

             updateCallUIBasedOnState('ended'); // Ensure UI resets
             console.log("Call sequence ended.");
        }

        function updateCallUIBasedOnState(state) {
             if (chatState !== 'CHATTING') {
                  callStatusDiv.textContent = ''; callButton.textContent = 'Start Audio Call'; callButton.disabled = true; return;
             }
             switch (state) {
                 case 'ringing':
                      get(ref(db, `chats/${userId}/call/initiator`)).then(snap => {
                         if(snap.val() === 'user') {
                             callStatusDiv.textContent = 'Calling Admin...'; callButton.textContent = 'Cancel Call'; callButton.disabled = false;
                         } else {
                             callStatusDiv.textContent = 'Incoming call...'; callButton.textContent = 'Answer'; callButton.disabled = false; // TODO: Implement Answer
                         }
                      });
                     break;
                 case 'active':
                     callStatusDiv.textContent = 'Call in progress'; callButton.textContent = 'End Call'; callButton.disabled = false;
                     break;
                 case 'ended':
                 case 'idle':
                 default:
                      get(ref(db, `chats/${userId}/call/endedBy`)).then(snap => {
                         const endedBy = snap.val();
                         callStatusDiv.textContent = state === 'ended' ? `Call ended${endedBy ? ' by ' + endedBy : ''}.` : '';
                      });
                     callButton.textContent = 'Start Audio Call'; callButton.disabled = false;
                     break;
             }
        }

        // --- Notifications ---
        function requestNotificationPermission() {
            if (!('Notification' in window)) return;
            if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission().then(p => console.log(`Notification permission: ${p}`));
            }
        }
        function showNotification(message) {
            if (!('Notification' in window) || Notification.permission !== 'granted') return;
            if (document.hidden) {
                const notification = new Notification('Chat Support', { body: message });
                setTimeout(notification.close.bind(notification), 5000);
            }
        }

        // --- Run Application ---
        initApp();

    </script>
</body>
</html>