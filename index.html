<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat with Support</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        html, body {
            height: 100%;
        }
        body {
            background: linear-gradient(to right, #6a11cb, #2575fc);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center the chat container vertically */
            align-items: center; /* Center the chat container horizontally */
            color: #fff;
            padding: 10px; /* Padding around container on large screens */
            overflow: hidden; /* Prevent body scroll */
        }

        /* Chat Container */
        .chat-container {
            width: 90%;
            max-width: 500px;
            height: 90vh; /* Adjusted height for better screen fit */
            max-height: 750px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            /* Adjusted Padding: Increased bottom padding */
            padding: 20px 20px 30px 20px; /* Top | R | Bottom | L */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.18);
            overflow: hidden; /* Container itself doesn't scroll */
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #admin-status .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 5px;
            vertical-align: middle;
            background-color: #ccc; /* Default offline (Grey) */
            transition: background-color 0.3s ease;
        }
        #admin-status .status-dot.online { background-color: #33ff33; } /* Green */
        #admin-status .status-dot.offline { background-color: #ccc; } /* Grey */

        /* Messages Area */
        .messages {
            flex: 1; /* Takes up available vertical space */
            overflow-y: auto; /* Allows scrolling ONLY for messages */
            margin-bottom: 15px; /* Space below messages */
            padding-right: 5px;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        .messages::-webkit-scrollbar { width: 6px; }
        .messages::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; }
        .messages::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }

        /* Message Styling */
        .message-wrapper {
             display: flex; margin-bottom: 12px; max-width: 85%; position: relative;
        }
        .message-wrapper.sent { align-self: flex-end; justify-content: flex-end; }
        .message-wrapper.received { align-self: flex-start; }
        .message-wrapper.bot { align-self: flex-start; }
        .message-wrapper p {
            padding: 10px 15px; border-radius: 18px; word-wrap: break-word;
            background: rgba(255, 255, 255, 0.2); color: #fff; line-height: 1.45;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .message-wrapper.sent p { background-color: #00c6ff; color: #111; border-bottom-right-radius: 5px; }
        .message-wrapper.received p { background-color: #ffd700; color: #111; border-bottom-left-radius: 5px; }
        .message-wrapper.bot p { background-color: rgba(255, 255, 255, 0.8); color: #333; border-bottom-left-radius: 5px; }

        /* Timestamp Styling */
        .timestamp {
            font-size: 0.7em; color: rgba(255, 255, 255, 0.65); margin-top: 4px;
            padding: 0 5px; display: block;
        }
        .message-wrapper.sent .timestamp { text-align: right; }
        .message-wrapper.received .timestamp, .message-wrapper.bot .timestamp { text-align: left; }

        /* Typing Indicator */
        #typing-indicator {
            min-height: 18px; font-style: italic; color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em; margin-bottom: 10px; /* Increased space below indicator */
            padding-left: 5px; transition: opacity 0.3s ease; flex-shrink: 0;
        }

        /* Input Area */
        .input-container {
            display: flex; gap: 10px;
            padding-top: 5px; /* Reduced space above input */
            flex-shrink: 0; /* Prevent shrinking */
        }
        input[type="text"] {
            flex: 1; padding: 12px 15px; border: none; border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.9); color: #333; outline: none; font-size: 1em;
        }
        input[type="text"]::placeholder { color: #888; }
        input[type="text"]:disabled { background-color: #ddd; cursor: not-allowed; }

        /* Buttons */
        button {
            padding: 12px 18px; border: none; border-radius: 10px; background-color: #00ffcc;
            color: #000; cursor: pointer; font-weight: bold; transition: background-color 0.2s ease;
            font-size: 0.95em;
        }
        button:hover:not(:disabled) { background-color: #00ccaa; }
        button:disabled { background-color: #aaa; cursor: not-allowed; color: #eee; }

        /* Audio Call Button */
        .audio-call {
            margin-top: 15px; /* Increased space above call button */
            background-color: #ff4f81; color: white; width: 100%; flex-shrink: 0;
        }
        .audio-call:hover:not(:disabled) { background-color: #f03a6a; }

        /* Call Status */
        #call-status {
             margin-top: 10px; /* Increased space above call status */
             text-align: center; font-weight: bold; min-height: 20px;
             font-size: 0.9em; flex-shrink: 0;
        }

        /* Hidden Audio Element */
        #remoteAudio { display: none; }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            body { padding: 0; } /* Full screen on mobile */
            .chat-container {
                width: 100%;
                height: 100vh; /* Use full viewport height */
                max-height: 100vh; /* Ensure it doesn't exceed */
                border-radius: 0;
                /* Adjusted Padding for Mobile: More space at bottom */
                padding: 15px 15px 25px 15px; /* T | R | B | L */
            }
            .chat-header { font-size: 0.8em; padding-bottom: 8px; margin-bottom: 10px;}
            .message-wrapper { max-width: 90%; }
            input[type="text"] { padding: 10px 12px; font-size: 0.95em; }
            button { padding: 10px 15px; font-size: 0.9em; }
            .audio-call { padding: 10px; margin-top: 12px; } /* Adjusted margin */
            #call-status { margin-top: 8px; }
            #typing-indicator { margin-bottom: 8px; }
        }
    </style>
</head>
<body>

    <!-- Main Chat UI -->
    <div class="chat-container">
        <div class="chat-header">
             <span>Chat with Support</span>
             <div id="admin-status">Admin: <span class="status-dot offline" title="Offline"></span></div>
        </div>
        <div class="messages" id="messages">
             <!-- Messages appear here -->
        </div>
        <div id="typing-indicator"></div>
        <div class="input-container">
            <input type="text" id="messageInput" placeholder="Loading chat..." autocomplete="off" disabled/>
            <button id="sendButton" disabled>Send</button>
        </div>
        <button class="audio-call" id="audioCallButton" disabled>Start Audio Call</button>
        <div id="call-status"></div>
    </div>

    <!-- Audio element to play remote stream -->
    <audio id="remoteAudio" autoplay></audio>

    <!-- Firebase SDK -->
    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getDatabase, ref, push, set, onValue, onChildAdded, serverTimestamp, onDisconnect, query, orderByChild, limitToLast, off, update, remove, get } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA5mBW5mXff46acu01BbPmZh8LGGXV42v8",
            authDomain: "chat-app-ddecb.firebaseapp.com",
            databaseURL: "https://chat-app-ddecb-default-rtdb.firebaseio.com",
            projectId: "chat-app-ddecb",
            storageBucket: "chat-app-ddecb.firebasestorage.app",
            messagingSenderId: "534760202357",
            appId: "1:534760202357:web:da7d90561af1c4220a183c",
            measurementId: "G-MCSSLKG71W"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const adminStatusDot = document.getElementById('admin-status').querySelector('.status-dot');
        const typingIndicatorDiv = document.getElementById('typing-indicator');
        const callButton = document.getElementById('audioCallButton');
        const callStatusDiv = document.getElementById('call-status');
        const remoteAudio = document.getElementById('remoteAudio');

        // --- State Variables ---
        let userId = localStorage.getItem('chatUserId');
        let userName = localStorage.getItem('chatUserName');
        let chatState = 'INITIALIZING'; // AWAITING_FIRST_MESSAGE -> AWAITING_NAME -> CHATTING
        let firstMessageSent = false;
        // Firebase Refs - Define top-level refs here
        let chatRef, messagesRef, userStatusRef, userTypingRef, adminTypingRef, callRef, metadataRef;
        const adminStatusDbRef = ref(db, 'adminStatus'); // *** CHANGED: Reference the parent adminStatus node ***
        let typingTimeout = null;
        let messageListener, adminStatusListener, adminTypingListener, callStateListener, callOfferListener, callAnswerListener, callAdminIceCandidateListener;

        // --- WebRTC State ---
        let peerConnection = null;
        let localStream = null;
        const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        let makingOffer = false;

        // --- Initialization ---
        function initApp() {
            console.log("Initializing App...");
            if (!userId) {
                userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
                localStorage.setItem('chatUserId', userId);
                console.log("Generated new userId:", userId);
            } else {
                console.log("Using existing userId:", userId);
            }

            // Define Firebase paths that depend on userId
            chatRef = ref(db, `chats/${userId}`);
            messagesRef = ref(db, `chats/${userId}/messages`);
            userStatusRef = ref(db, `chats/${userId}/status`);
            callRef = ref(db, `chats/${userId}/call`);
            userTypingRef = ref(db, `chats/${userId}/status/userTyping`);
            adminTypingRef = ref(db, `chats/${userId}/status/adminTyping`);
            metadataRef = ref(db, `chats/${userId}/metadata`);

            // Core event listeners
            sendButton.onclick = handleSendAction;
            messageInput.onkeydown = handleInputKeyDown;
            callButton.onclick = handleCallButtonClick;

            // Determine initial state
            userName = localStorage.getItem('chatUserName');
            if (userName) {
                chatState = 'CHATTING';
                firstMessageSent = true;
                enableChattingUI();
                startChatSession();
            } else {
                chatState = 'AWAITING_FIRST_MESSAGE';
                messageInput.disabled = false; sendButton.disabled = false; callButton.disabled = true;
                messageInput.placeholder = "Type a message to start...";
                messagesDiv.innerHTML = '<div class="message-wrapper bot"><p>Welcome! Type anything to begin.</p></div>';
                scrollToBottom();
            }

            requestNotificationPermission();
            listenToAdminStatus(); // Start listening immediately
        }

        // --- Name Handling ---
        function handleFirstMessage(messageText) {
            console.log("Handling first message.");
            firstMessageSent = true;
            displayMessage('sent', messageText, Date.now(), `local-${Date.now()}`);
            displayMessage('bot', 'Thanks! To connect you, please tell me your name:');
            chatState = 'AWAITING_NAME';
            messageInput.placeholder = "Enter your name here...";
            messageInput.focus();
        }

        function handleNameSubmission(name) {
            if (!name) {
                displayMessage('bot', 'Please enter your name.');
                messageInput.placeholder = "Enter your name again...";
                return;
            }
            userName = name;
            localStorage.setItem('chatUserName', userName);
            chatState = 'CHATTING';
            console.log(`Username set: ${userName}`);

            displayMessage('sent', name, Date.now(), `local-${Date.now()}-name`);
            displayMessage('bot', `Got it, ${userName}! Chat active.`);

            messageInput.value = ''; messageInput.placeholder = "Type your message...";

            set(metadataRef, {
                userName: userName, userId: userId,
                firstSeen: serverTimestamp(), lastActive: serverTimestamp()
            }).then(() => {
                console.log("Metadata saved.");
                enableChattingUI();
                startChatSession();
            }).catch(error => {
                console.error("Metadata save error:", error);
                displayMessage('bot', "Error saving name. Please refresh.");
                disableChattingUI();
            });
        }

        // --- UI State ---
        function enableChattingUI() {
            messageInput.disabled = false; sendButton.disabled = false; callButton.disabled = false;
            messageInput.placeholder = "Type your message...";
        }
        function disableChattingUI() {
             messageInput.disabled = true; sendButton.disabled = true; callButton.disabled = true;
        }

        // --- Firebase Session ---
        function startChatSession() {
            if (!userId || !userName) return;
            console.log("Starting Firebase session listeners...");

            cleanupFirebaseListeners(false); // Keep admin status listener active

            // Presence
            const userOnlineRef = ref(db, `chats/${userId}/status/userOnline`);
            const connectedRef = ref(db, '.info/connected');
            onValue(connectedRef, (snap) => {
                if (snap.val() === true) {
                    set(userOnlineRef, true);
                    update(metadataRef, { lastActive: serverTimestamp() });
                    onDisconnect(userOnlineRef).set(false);
                    onDisconnect(metadataRef).update({ lastActive: serverTimestamp() });
                }
            });

            // Messages
            const messagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(100));
            let initialLoadComplete = false;
            messageListener = onChildAdded(messagesQuery, (snapshot) => {
                 const msgId = snapshot.key, msg = snapshot.val();
                 if (messagesDiv.querySelector(`.message-wrapper[data-msg-id="${msgId}"]`)) return; // Skip duplicates
                 if (msg) {
                    displayMessage(msg.sender === 'user' ? 'sent' : (msg.sender === 'admin' ? 'received' : 'bot'), msg.text, msg.timestamp, msgId);
                    if (msg.sender === 'admin' && document.hidden) showNotification(`New message`);
                 }
                 if (initialLoadComplete) scrollToBottom();
            }, (error) => console.error("Msg listener error:", error));
            onValue(messagesQuery, () => { if (!initialLoadComplete) { scrollToBottom(); initialLoadComplete = true; } }, { onlyOnce: true });

            // Admin Typing
            adminTypingListener = onValue(adminTypingRef, (s) => { typingIndicatorDiv.textContent = s.val() ? 'Admin is typing...' : ''; }, (e) => console.error("Admin typing listener error:", e));

            // Call Listeners
            listenForCallChanges();
        }

        // --- Listener Cleanup ---
         function cleanupFirebaseListeners(includeAdminStatus = true) {
             console.log("Cleaning listeners...");
             if (messageListener) off(messagesRef, 'child_added', messageListener);
             if (includeAdminStatus && adminStatusListener) off(adminStatusDbRef, 'value', adminStatusListener); // Use correct ref
             if (adminTypingListener) off(adminTypingRef, 'value', adminTypingListener);
             if (callStateListener) off(ref(db, `chats/${userId}/call/state`), 'value', callStateListener);
             if (callOfferListener) off(ref(db, `chats/${userId}/call/offer`), 'value', callOfferListener);
             if (callAnswerListener) off(ref(db, `chats/${userId}/call/answer`), 'value', callAnswerListener);
             if (callAdminIceCandidateListener) off(ref(db, `chats/${userId}/call/adminIceCandidates`), 'child_added', callAdminIceCandidateListener);
             messageListener = null; if (includeAdminStatus) adminStatusListener = null;
             adminTypingListener = null; callStateListener = null; callOfferListener = null; callAnswerListener = null; callAdminIceCandidateListener = null;
         }


        // --- Core Actions ---
        function handleSendAction() {
            const messageText = messageInput.value.trim();
            if (chatState === 'AWAITING_FIRST_MESSAGE') { if (!messageText) return; handleFirstMessage(messageText); messageInput.value = ''; }
            else if (chatState === 'AWAITING_NAME') { if (!messageText) { displayMessage('bot', 'Please enter name.'); return; } handleNameSubmission(messageText); }
            else if (chatState === 'CHATTING') { if (!messageText) return; sendChatMessage(messageText); messageInput.value = ''; }
            else { console.warn("Send in unexpected state:", chatState); }
        }
        function handleInputKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendAction(); }
            else if (chatState === 'CHATTING') { handleUserTyping(); }
        }
        function sendChatMessage(msgText) {
            if (!userId || !userName || !msgText) return;
            messageInput.focus();
            const msgData = { sender: 'user', text: msgText, timestamp: serverTimestamp(), userId: userId, userName: userName };
            push(messagesRef, msgData).then(() => {
                if (userTypingRef) set(userTypingRef, false); clearTimeout(typingTimeout);
                update(metadataRef, { lastActive: serverTimestamp() });
            }).catch(e => { console.error("Send msg error:", e); displayMessage('bot', "Msg send failed."); });
        }

        // --- Display & Scroll ---
        function displayMessage(senderType, text, timestamp, msgId = null) {
            const wrapper = document.createElement('div'); wrapper.classList.add('message-wrapper', senderType); if (msgId) wrapper.dataset.msgId = msgId;
            const p = document.createElement('p'); p.textContent = text; wrapper.appendChild(p);
            const timeSpan = document.createElement('span'); timeSpan.classList.add('timestamp');
            if (senderType !== 'bot' && timestamp) { timeSpan.textContent = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
            else { timeSpan.textContent = ''; }
            wrapper.appendChild(timeSpan); messagesDiv.appendChild(wrapper);
            // Scroll handled elsewhere
        }
        function scrollToBottom() { requestAnimationFrame(() => { messagesDiv.scrollTop = messagesDiv.scrollHeight; }); }

        // --- Typing Indicator ---
        function handleUserTyping() {
            if (chatState !== 'CHATTING' || !userTypingRef) return;
            set(userTypingRef, true); clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => { set(userTypingRef, false); }, 2500);
        }

        // --- Admin Status Listener ---
        function listenToAdminStatus() {
             // *** FIXED: Listen to the correct path and check the 'online' property ***
             if (adminStatusListener) off(adminStatusDbRef, 'value', adminStatusListener); // Use correct ref
             console.log("Setting up admin status listener on:", adminStatusDbRef.toString()); // Verify path

             adminStatusListener = onValue(adminStatusDbRef, (snapshot) => {
                const adminData = snapshot.val(); // Get the whole object { online: ..., lastOnline: ... } or null
                const isOnline = adminData?.online === true; // Check the 'online' property within the object
                console.log("Admin status data received:", adminData, "Is Online:", isOnline); // Enhanced log

                adminStatusDot.classList.toggle('online', isOnline);
                adminStatusDot.classList.toggle('offline', !isOnline);
                adminStatusDot.title = isOnline ? 'Online' : 'Offline';
             }, (error) => {
                 console.error("Admin status listener error:", error);
                 // Handle error: maybe default to offline?
                 adminStatusDot.classList.remove('online');
                 adminStatusDot.classList.add('offline');
                 adminStatusDot.title = 'Offline (Error)';
             });
        }

        // --- Audio Call & WebRTC ---
        // (WebRTC functions: handleCallButtonClick, startCallSequence, createPeerConnection, handleIceCandidate,
        // handleRemoteTrack, handleIceConnectionStateChange, handleConnectionStateChange, listenForCallChanges,
        // closePeerConnection, stopLocalStream, endCallSequence, updateCallUIBasedOnState remain the same as previous response)

        function handleCallButtonClick() {
             if (callButton.textContent === 'Start Audio Call') { startCallSequence(); }
             else { endCallSequence(); }
         }
        async function startCallSequence() {
            if (chatState !== 'CHATTING' || !callRef || !userName) { displayMessage('bot', "Chat not active for calls."); return; }
            console.log('Starting call sequence...'); callButton.disabled = true; callStatusDiv.textContent = 'Requesting Mic...';
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                console.log("Mic granted."); callStatusDiv.textContent = 'Connecting...';
            } catch (error) {
                console.error("Mic error:", error); callStatusDiv.textContent = 'Mic denied!';
                displayMessage('bot', "Mic needed for calls."); callButton.disabled = false; return;
            }
            if (!createPeerConnection()) { callStatusDiv.textContent = 'Call setup failed.'; endCallSequence(); return; }
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            console.log("Local track added.");
             try {
                makingOffer = true;
                await set(callRef, { state: 'ringing', initiator: 'user', timestamp: serverTimestamp(), userName: userName, offer: null, answer: null, userIceCandidates: null, adminIceCandidates: null });
                console.log("State 'ringing'. Creating offer...");
                 const offer = await peerConnection.createOffer(); await peerConnection.setLocalDescription(offer);
                 console.log("Offer created & set local.");
                 await set(ref(db, `chats/${userId}/call/offer`), { type: offer.type, sdp: offer.sdp });
                 console.log("Offer sent."); updateCallUIBasedOnState('ringing');
             } catch (error) {
                 console.error("Offer error:", error); callStatusDiv.textContent = 'Call setup failed.';
                 displayMessage('bot', "Call setup error."); endCallSequence();
             } finally { makingOffer = false; }
        }
        function createPeerConnection() {
             console.log("Creating Peer Connection...");
             try {
                peerConnection = new RTCPeerConnection(iceServers);
                peerConnection.onicecandidate = handleIceCandidate; peerConnection.ontrack = handleRemoteTrack;
                peerConnection.oniceconnectionstatechange = handleIceConnectionStateChange; peerConnection.onconnectionstatechange = handleConnectionStateChange;
                 console.log("Peer Connection created."); return true;
             } catch (error) { console.error("PC creation failed:", error); return false; }
        }
        function handleIceCandidate(event) {
            if (event.candidate) { console.log("Generated ICE candidate..."); push(ref(db, `chats/${userId}/call/userIceCandidates`), event.candidate.toJSON()).catch(e => console.error("Send ICE error:", e)); }
            else { console.log("All ICE sent."); }
        }
        function handleRemoteTrack(event) {
            console.log("Remote track:", event.track.kind);
            if (event.streams && event.streams[0] && remoteAudio) { console.log("Assigning remote stream."); remoteAudio.srcObject = event.streams[0]; remoteAudio.play().catch(e => console.warn("Remote play failed:", e)); }
            else { console.warn("Could not assign remote stream."); }
        }
        function handleIceConnectionStateChange() {
            if (!peerConnection) return; console.log("ICE State:", peerConnection.iceConnectionState);
            if (peerConnection.iceConnectionState === 'failed') { console.error("ICE Failed."); displayMessage('bot', "Call connection failed (ICE)."); endCallSequence(); }
        }
         function handleConnectionStateChange() {
             if (!peerConnection) return; console.log("Connection State:", peerConnection.connectionState);
             switch (peerConnection.connectionState) {
                 case "connected": console.log("Peers connected!"); break;
                 case "disconnected": console.log("Peers disconnected."); break;
                 case "failed": console.error("Connection failed."); displayMessage('bot', "Call connection failed."); endCallSequence(); break;
                 case "closed": console.log("Connection closed."); endCallSequence(); break;
             }
         }
        function listenForCallChanges() {
             console.log("Setting call listeners...");
             const stateRef = ref(db, `chats/${userId}/call/state`); const answerRef = ref(db, `chats/${userId}/call/answer`);
             const adminIceRef = ref(db, `chats/${userId}/call/adminIceCandidates`); const offerRef = ref(db, `chats/${userId}/call/offer`);

             if (callStateListener) off(stateRef, 'value', callStateListener); if (callAnswerListener) off(answerRef, 'value', callAnswerListener);
             if (callAdminIceCandidateListener) off(adminIceRef, 'child_added', callAdminIceCandidateListener); if (callOfferListener) off(offerRef, 'value', callOfferListener);

             callStateListener = onValue(stateRef, (s) => { const newState = s.val(); console.log("Call state:", newState); updateCallUIBasedOnState(newState); if (newState === 'ended' || newState === 'idle' || !newState) { if (peerConnection && peerConnection.connectionState !== "closed") { console.log("Remote end, cleaning up."); closePeerConnection(); stopLocalStream(); } } });
             callAnswerListener = onValue(answerRef, async (s) => { const answer = s.val(); if (peerConnection && peerConnection.signalingState === 'have-local-offer' && answer) { console.log("Received answer."); try { await peerConnection.setRemoteDescription(new RTCSessionDescription(answer)); console.log("Remote answer set."); } catch (e) { console.error("Set remote answer error:", e); } } });
             callAdminIceCandidateListener = onChildAdded(adminIceRef, (s) => { if (s.exists()) { const cand = s.val(); console.log("Received admin ICE."); if (peerConnection && peerConnection.remoteDescription) { peerConnection.addIceCandidate(new RTCIceCandidate(cand)).then(() => console.log("Admin ICE added.")).catch(e => console.error("Add admin ICE error:", e)); } else { console.warn("Admin ICE but PC not ready."); } remove(s.ref); } });
             callOfferListener = onValue(offerRef, async (s) => { const offer = s.val(); const callState = await get(ref(db, `chats/${userId}/call/state`)).then(sn => sn.val()); if (!makingOffer && offer && callState === 'ringing' && peerConnection?.signalingState === 'stable') { console.log("Received offer (Admin init?)."); displayMessage('bot', "Incoming call!"); updateCallUIBasedOnState('ringing'); console.warn("Answering admin calls not fully implemented."); } });
        }
        function closePeerConnection() { if (peerConnection) { console.log("Closing PC."); peerConnection.onicecandidate = null; peerConnection.ontrack = null; peerConnection.oniceconnectionstatechange = null; peerConnection.onconnectionstatechange = null; peerConnection.close(); peerConnection = null; } }
        function stopLocalStream() { if (localStream) { console.log("Stopping local stream."); localStream.getTracks().forEach(t => t.stop()); localStream = null; } if(remoteAudio) remoteAudio.srcObject = null; }
        async function endCallSequence() {
             console.log("Ending call sequence..."); stopLocalStream(); closePeerConnection();
              try {
                 const stateSnap = await get(ref(db, `chats/${userId}/call/state`));
                 if (stateSnap.exists() && stateSnap.val() !== 'ended' && stateSnap.val() !== 'idle') {
                     await update(callRef, { state: 'ended', endedBy: 'user', endTimestamp: serverTimestamp() });
                     console.log("Call state 'ended'."); remove(ref(db, `chats/${userId}/call/offer`)); remove(ref(db, `chats/${userId}/call/answer`)); remove(ref(db, `chats/${userId}/call/userIceCandidates`)); remove(ref(db, `chats/${userId}/call/adminIceCandidates`));
                 } else { console.log("Call already ended/idle."); }
             } catch (e) { console.error("Error ending call in FB:", e); }
             updateCallUIBasedOnState('ended'); console.log("Call sequence ended.");
        }
        function updateCallUIBasedOnState(state) { // Simplified - assumes user initiated ringing if ambiguous
             if (chatState !== 'CHATTING') { callStatusDiv.textContent=''; callButton.textContent='Start Audio Call'; callButton.disabled=true; return; }
             switch (state) {
                 case 'ringing': callStatusDiv.textContent = 'Calling/Incoming...'; callButton.textContent = 'Cancel Call'; callButton.disabled = false; break; // Simplification for UI
                 case 'active': callStatusDiv.textContent = 'Call in progress'; callButton.textContent = 'End Call'; callButton.disabled = false; break;
                 case 'ended': case 'idle': default:
                      get(ref(db, `chats/${userId}/call/endedBy`)).then(s=>{ const endedBy=s.val(); callStatusDiv.textContent = state==='ended'?`Call ended${endedBy?' by '+endedBy:''}.`:''; });
                      callButton.textContent = 'Start Audio Call'; callButton.disabled = false; break;
             }
        }

        // --- Notifications ---
        function requestNotificationPermission() { /* Same as before */ if(!('Notification'in window))return; if(Notification.permission!=='granted'&&Notification.permission!=='denied')Notification.requestPermission().then(p=>console.log(`Notify permission:${p}`)); }
        function showNotification(message) { /* Same as before */ if(!('Notification'in window)||Notification.permission!=='granted')return; if(document.hidden){const n=new Notification('Chat Support',{body:message});setTimeout(n.close.bind(n),5000);} }

        // --- Run Application ---
        initApp();

    </script>
</body>
</html>