<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat Support</title>
    <!-- Using styles similar to Revision 3 for layout -->
    <style>
        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        html, body { height: 100%; }
        body { background: linear-gradient(to right, #6a11cb, #2575fc); min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; padding: 10px; }

        /* --- Chat Container --- */
        .chat-container { width: 95%; max-width: 550px; height: 90vh; max-height: 750px; background-color: rgba(255, 255, 255, 0.15); border-radius: 15px; padding: 15px 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); display: flex; flex-direction: column; border: 1px solid rgba(255, 255, 255, 0.18); overflow: hidden; }

        /* --- Chat Header --- */
        .chat-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); font-size: 0.95em; flex-shrink: 0; }
        #admin-status .status-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-left: 5px; vertical-align: middle; background-color: #ccc; transition: background-color 0.3s ease; }
        #admin-status .status-dot.online { background-color: #33ff33; } #admin-status .status-dot.offline { background-color: #ccc; }

        /* --- Messages Area --- */
        .messages { flex: 1; overflow-y: auto; margin-bottom: 10px; padding-right: 5px; display: flex; flex-direction: column; scrollbar-width: thin; scrollbar-color: rgba(255,255,255,0.3) transparent; }
        .messages::-webkit-scrollbar { width: 6px; } .messages::-webkit-scrollbar-track { background: transparent; border-radius: 3px;} .messages::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.4); border-radius: 3px;}

        /* --- Message Styling --- */
        .message { padding: 10px 14px; border-radius: 10px; max-width: 80%; word-wrap: break-word; line-height: 1.4; font-size: 0.95em; position: relative; background: rgba(255, 255, 255, 0.2); color: #fff; animation: fadeIn 0.3s ease-out; opacity: 0; animation-fill-mode: forwards; margin-bottom: 10px; /* Added margin */ }
        .message p { margin: 0; padding: 0; }
        .message.sent { align-self: flex-end; background-color: #00c6ff; color: #000; border-bottom-right-radius: 5px; }
        .message.received { align-self: flex-start; background-color: #ffd700; color: #000; border-bottom-left-radius: 5px; }
        .message.bot { align-self: flex-start; background-color: rgba(255, 255, 255, 0.8); color: #333; border-bottom-left-radius: 5px;}
        .message .timestamp { font-size: 0.7em; display: block; margin-top: 4px; text-align: right; }
        .message.sent .timestamp { color: rgba(0, 0, 0, 0.6); } .message.received .timestamp { color: rgba(0, 0, 0, 0.7); }
        .message.bot .timestamp { display: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Typing Indicator --- */
        #typing-indicator { min-height: 18px; font-style: italic; color: rgba(255, 255, 255, 0.7); font-size: 0.85em; margin-bottom: 10px; flex-shrink: 0; }

        /* --- Input Area Container --- */
        .input-area-container { padding-top: 10px; flex-shrink: 0; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        /* Input Row */
        .input-row { display: flex; gap: 10px; margin-bottom: 10px; }
        #messageInput { flex: 1; padding: 12px 15px; border: none; border-radius: 10px; background-color: rgba(255, 255, 255, 0.9); color: #333; outline: none; font-size: 0.95em; }
        #messageInput::placeholder { color: #777; }
        #messageInput:disabled { background-color: #ddd; cursor: not-allowed; }
        #sendButton { padding: 12px 18px; border: none; border-radius: 10px; background-color: #00ffcc; color: #000; cursor: pointer; font-weight: bold; transition: background-color 0.2s ease, opacity 0.2s ease; font-size: 0.95em; }
        #sendButton:hover:not(:disabled) { background-color: #00ccaa; }
        #sendButton:disabled { background-color: #aaa; cursor: not-allowed; opacity: 0.7; }

        /* --- Audio Call Button --- */
        .audio-call-button-container { margin-bottom: 5px; }
        #audioCallButton { background-color: #ff4f81; color: white; width: 100%; padding: 11px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; transition: background-color 0.2s ease, opacity 0.2s ease; font-size: 0.95em; }
        #audioCallButton:hover:not(:disabled) { background-color: #f03a6a; }
        #audioCallButton:disabled { background-color: #aaa; cursor: not-allowed; opacity: 0.7; }
        /* Call Status */
        #call-status { text-align: center; font-weight: bold; min-height: 18px; font-size: 0.8em; color: rgba(255, 255, 255, 0.8); }

        /* --- Incoming Call Alert (Hidden by default) --- */
        #incoming-call-alert {
            display: none; /* Hidden initially */
            position: absolute;
            bottom: 80px; /* Position above input area */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 167, 69, 0.9); /* Greenish */
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        #incoming-call-alert p { margin-bottom: 10px; font-size: 1.1em; }
        #incoming-call-alert button {
            padding: 8px 15px; margin: 0 5px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: background-color 0.2s ease;
        }
        #acceptCallButton { background-color: #33ff33; color: #000; }
        #rejectCallButton { background-color: #ff4f81; color: white; }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            body { padding: 0; }
            .chat-container { width: 100%; height: 100%; max-height: none; border-radius: 0; padding: 10px 12px; }
            .chat-header { padding-bottom: 8px; margin-bottom: 8px; font-size: 0.9em; }
            .messages { margin-bottom: 8px; } #typing-indicator { margin-bottom: 8px; }
            .input-area-container { padding-top: 8px; }
            .input-row { gap: 8px; margin-bottom: 8px;}
            #messageInput { padding: 10px 12px; font-size: 0.9em;}
            #sendButton { padding: 10px 15px; font-size: 0.9em;}
            #audioCallButton { padding: 10px; font-size: 0.9em;}
            #call-status { font-size: 0.75em; }
            .message { max-width: 90%; }
            #incoming-call-alert { width: 90%; bottom: 90px; padding: 12px 15px; }
            #incoming-call-alert p { font-size: 1em; }
            #incoming-call-alert button { padding: 7px 12px; }
        }

         /* Hidden Audio Elements */
         .hidden-audio { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <!-- Main Chat UI -->
    <div class="chat-container">
        <div class="chat-header">
             <span>Chat Support</span>
             <div id="admin-status">Admin: <span class="status-dot offline" title="Offline"></span></div>
        </div>
        <div class="messages" id="messages">
             <!-- Bot prompt & messages appear here -->
        </div>
        <div id="typing-indicator"></div>
        <div class="input-area-container">
             <div class="input-row">
                 <input type="text" id="messageInput" placeholder="Loading..." autocomplete="off" disabled/>
                 <button id="sendButton" disabled>Send</button>
             </div>
             <div class="audio-call-button-container">
                 <button class="audio-call" id="audioCallButton" disabled>Audio Call</button>
             </div>
             <div id="call-status"></div>
        </div>

        <!-- Incoming Call Alert -->
        <div id="incoming-call-alert">
            <p>Incoming Call from Admin</p>
            <button id="acceptCallButton">Accept</button>
            <button id="rejectCallButton">Reject</button>
        </div>

        <!-- Hidden Audio Elements for WebRTC -->
        <audio id="localAudio" autoplay muted class="hidden-audio"></audio>
        <audio id="remoteAudio" autoplay class="hidden-audio"></audio>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getDatabase, ref, push, set, onValue, onChildAdded, serverTimestamp, onDisconnect, query, orderByChild, limitToLast, off, update, remove, get } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js"; // Added get

        // Firebase configuration
        const firebaseConfig = {
             apiKey: "AIzaSyA5mBW5mXff46acu01BbPmZh8LGGXV42v8", authDomain: "chat-app-ddecb.firebaseapp.com", databaseURL: "https://chat-app-ddecb-default-rtdb.firebaseio.com", projectId: "chat-app-ddecb", storageBucket: "chat-app-ddecb.firebasestorage.app", messagingSenderId: "534760202357", appId: "1:534760202357:web:da7d90561af1c4220a183c", measurementId: "G-MCSSLKG71W"
        };
        const ADMIN_EMAIL = "cnow20874@gmail.com"; // For email trigger simulation
        const ADMIN_PANEL_BASE_URL = "https://cool-moonbeam-685338.netlify.app/"; // For email trigger simulation

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const adminStatusSpan = document.getElementById('admin-status').querySelector('.status-dot');
        const typingIndicatorDiv = document.getElementById('typing-indicator');
        const callButton = document.getElementById('audioCallButton');
        const callStatusDiv = document.getElementById('call-status');
        const localAudio = document.getElementById('localAudio');
        const remoteAudio = document.getElementById('remoteAudio');
        const incomingCallAlert = document.getElementById('incoming-call-alert');
        const acceptCallButton = document.getElementById('acceptCallButton');
        const rejectCallButton = document.getElementById('rejectCallButton');

        // --- State Variables ---
        let userId = null; let userName = null; let chatState = 'AWAITING_NAME';
        let chatRef = null; let messagesRef = null; let userStatusRef = null; let userTypingRef = null; let adminTypingRef = null; let callRef = null; let adminOnlineRef = ref(db, 'adminStatus/online'); let userMetadataRef = null; let connectedRef = ref(db, '.info/connected');
        let typingTimeout = null; let messageListener = null; let adminStatusListener = null; let adminTypingListener = null; let callListener = null; let connectedListener = null; let blockListener = null;
        let peerConnection = null; let localStream = null; let callSignalListeners = {}; // { answer: listener, ice: listener }
        const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        // --- Log Helper ---
        function log(level, ...args) { console[level](`[User]`, ...args); }

        // --- Initialization ---
        function initApp() {
            displayBotMessage("Welcome! Please enter your name to begin.");
            messageInput.placeholder = "Enter your name...";
            messageInput.disabled = false; sendButton.disabled = false; callButton.disabled = true; callStatusDiv.textContent = '';
            requestNotificationPermission();
            sendButton.onclick = handleUserInput; messageInput.onkeypress = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUserInput(); } };
            callButton.onclick = handleCallButtonClick;
            acceptCallButton.onclick = joinIncomingAdminCall; // Handler for accepting admin call
            rejectCallButton.onclick = rejectIncomingAdminCall; // Handler for rejecting admin call
        }

        // --- Input Handling ---
        function handleUserInput() {
            const inputText = messageInput.value.trim(); if (!inputText) return; messageInput.value = '';
            if (chatState === 'AWAITING_NAME') { processNameInput(inputText); }
            else if (chatState === 'CHATTING') { sendMessage(inputText); }
        }

        // --- Name Processing & Setup ---
        function processNameInput(name) {
            if (!name || name.length > 30) { displayBotMessage(name ? "Name too long (max 30)." : "Name cannot be empty."); return; }
            userName = name; userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 7); chatState = 'INITIALIZING';
            displayMessageInternal('sent', userName); messageInput.placeholder = "Connecting..."; messageInput.disabled = true; sendButton.disabled = true; callButton.disabled = true;
            displayBotMessage(`Thanks, ${userName}! Setting up chat...`); log('info', `Initializing chat for ${userName} (${userId})`);
            setupFirebaseConnection();
        }
        async function setupFirebaseConnection() {
            if (!userId || !userName) { log('error',"User ID/Name missing."); displayBotMessage("Error. Refresh."); chatState = 'AWAITING_NAME'; messageInput.placeholder = "Enter name..."; messageInput.disabled = false; sendButton.disabled = false; return; }
            chatRef = ref(db, `chats/${userId}`); messagesRef = ref(db, `chats/${userId}/messages`); userStatusRef = ref(db, `chats/${userId}/status`); callRef = ref(db, `chats/${userId}/call`); userTypingRef = ref(db, `chats/${userId}/status/userTyping`); adminTypingRef = ref(db, `chats/${userId}/status/adminTyping`); userMetadataRef = ref(db, `chats/${userId}/metadata`); const userBlockRef = ref(db, `chats/${userId}/metadata/isBlocked`);
            cleanupListeners();
            try {
                await set(userMetadataRef, { userName: userName, userId: userId, firstSeen: serverTimestamp(), lastActive: serverTimestamp(), isBlocked: false });
                // --- Check Admin Status for Email Trigger ---
                get(adminOnlineRef).then(snap => {
                    if (snap.exists() && snap.val() === false) {
                        const uniqueUrl = `${ADMIN_PANEL_BASE_URL}?user=${userId}`;
                        log('warn', `** EMAIL TRIGGER (User Connect): To ${ADMIN_EMAIL}, User: ${userName}, Link: ${uniqueUrl}`);
                        // **** FIREBASE FUNCTION NEEDED HERE ****
                    }
                }).catch(e => log('error', "Error checking admin status:", e));
                // --- End Email Check ---
                const userOnlineRef = ref(db, `chats/${userId}/status/userOnline`);
                globalListeners.connected = onValue(connectedRef, async (snap) => { if (snap.val() === true) { log('debug',"Firebase connected."); await set(userOnlineRef, true); await update(userMetadataRef, { lastActive: serverTimestamp() }); onDisconnect(chatRef).remove(); onDisconnect(userOnlineRef).set(false); } else { log('debug',"Firebase disconnected."); } });
                const messagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(50)); messagesDiv.innerHTML = '';
                globalListeners.messages = onChildAdded(messagesQuery, handleNewMessage);
                globalListeners.adminStatus = onValue(adminOnlineRef, handleAdminStatusChange);
                globalListeners.adminTyping = onValue(adminTypingRef, handleAdminTypingChange);
                globalListeners.call = onValue(callRef, handleCallStateChange); // Main call listener
                globalListeners.block = onValue(userBlockRef, handleBlockStatusChange);
                chatState = 'CHATTING'; messageInput.placeholder = "Type message..."; messageInput.disabled = false; sendButton.disabled = false; callButton.disabled = false; messageInput.focus(); displayBotMessage("Connected! Send messages or start a call."); log('info',"Chat setup complete.");
            } catch (error) { log('error',"Firebase setup failed:", error); displayBotMessage("Connection failed. Refresh."); chatState = 'AWAITING_NAME'; messageInput.placeholder = "Enter name..."; messageInput.disabled = false; sendButton.disabled = false; }
        }

        // --- Listener Handlers ---
        function handleNewMessage(snapshot) {
             if (chatState === 'BLOCKED') return; const msg = snapshot.val(); const msgId = snapshot.key;
             if (msg && !messagesDiv.querySelector(`.message[data-msg-id="${msgId}"]`)) {
                 displayMessageInternal(msg.sender, msg.text, msg.timestamp, msgId);
                 if (msg.sender === 'admin' && document.hidden) { showNotification(`New message from Admin`); }
             }
        }
        function handleAdminStatusChange(snapshot) {
             const isOnline = snapshot.val(); log('debug',"Admin status:", isOnline); adminStatusSpan.classList.toggle('online', isOnline); adminStatusSpan.classList.toggle('offline', !isOnline); adminStatusSpan.title = isOnline ? 'Online' : 'Offline';
        }
        function handleAdminTypingChange(snapshot) {
             if (chatState === 'CHATTING') { typingIndicatorDiv.textContent = snapshot.val() ? 'Admin is typing...' : ''; }
        }
        function handleCallStateChange(snapshot) { // Handles ALL call state updates
             if (chatState === 'BLOCKED') return;
             const callState = snapshot.val(); log('debug',"Call state changed:", callState);
             updateCallUI(callState); // Update main button/status

             // Handle incoming call alert specifically
             if (callState?.state === 'admin-ringing' && callState.initiator === 'admin') {
                 showIncomingCallAlert(callState.offer); // Show the alert div
             } else {
                 hideIncomingCallAlert(); // Hide alert for any other state
             }
        }
        function handleBlockStatusChange(snapshot) {
             const isBlocked = snapshot.val(); if (isBlocked === true && chatState !== 'BLOCKED') { log('warn',"User blocked."); chatState = 'BLOCKED'; handleBlockedStateUI(); }
        }

        // --- Blocked State Handling ---
        function handleBlockedStateUI() {
            messageInput.disabled = true; sendButton.disabled = true; callButton.disabled = true; callStatusDiv.textContent = "Chat Blocked by Admin"; typingIndicatorDiv.textContent = ''; displayBotMessage("You have been blocked by the admin."); hideIncomingCallAlert(); if (peerConnection) { hangUpCall(false); }
            // Optionally cleanup listeners earlier
            // cleanupListeners();
        }

        // --- Messaging ---
        function sendMessage(msgText) {
            if (!msgText || chatState !== 'CHATTING' || !userId) { log('warn',"Send prevented. State:", chatState); return; }
             const messageData = { sender: 'user', text: msgText, timestamp: serverTimestamp(), userId: userId, userName: userName };
             messageInput.disabled = true; sendButton.disabled = true; // Disable temporarily
             push(messagesRef, messageData).then(() => {
                 log('debug','Msg sent'); if (userTypingRef) set(userTypingRef, false); clearTimeout(typingTimeout); update(userMetadataRef, { lastActive: serverTimestamp() });
                 // --- Check Admin Status for Email Trigger ---
                 get(adminOnlineRef).then(snap => { if (snap.exists() && snap.val() === false) { const uniqueUrl = `${ADMIN_PANEL_BASE_URL}?user=${userId}`; log('warn', `** EMAIL TRIGGER (User Message): To ${ADMIN_EMAIL}, User: ${userName}, Link: ${uniqueUrl}`); /* Trigger Firebase Function */ } }).catch(e => log('error', "Error checking admin status:", e));
                 // --- End Email Check ---
             }).catch(error => { log('error',"Send failed:", error); displayBotMessage("Error: Send failed."); }).finally(() => { if (chatState === 'CHATTING') { messageInput.disabled = false; sendButton.disabled = false; messageInput.focus(); } });
        }
        function displayMessageInternal(sender, text, timestamp, msgId) { // Simplified internal display
             if (!messagesDiv) return; const existingMsg = messagesDiv.querySelector(`div.message[data-msg-id="${msgId}"]`); if (existingMsg) return;
             const wrapper = document.createElement('div'); wrapper.classList.add('message', sender); wrapper.dataset.msgId = msgId; const p = document.createElement('p'); p.textContent = text; wrapper.appendChild(p);
             if (sender !== 'bot') { const timeSpan = document.createElement('span'); timeSpan.classList.add('timestamp'); timeSpan.textContent = formatTimestamp(timestamp); wrapper.appendChild(timeSpan); }
             messagesDiv.appendChild(wrapper); scrollToBottom(); void wrapper.offsetWidth; wrapper.style.animationPlayState = 'running';
        }
         function displayBotMessage(text) { displayMessageInternal('bot', text, null, 'bot-' + Date.now()); }
        function scrollToBottom() { setTimeout(() => { messagesDiv.scrollTop = messagesDiv.scrollHeight; }, 50); }

        // --- Typing Indicator ---
        function handleUserTyping() { if (!userTypingRef || chatState !== 'CHATTING') return; set(userTypingRef, true); clearTimeout(typingTimeout); typingTimeout = setTimeout(() => { set(userTypingRef, false); }, 2000); }
        messageInput.oninput = handleUserTyping; // Trigger on input change

        // --- WebRTC Audio Call (Adapted from Admin Panel) ---

        // Create Peer Connection (User context)
        async function createPeerConnection() {
             log('debug', `Attempting PeerConnection...`);
             if (!window.isSecureContext) { const msg = "Mic access requires HTTPS/localhost."; log('error', msg); displayBotMessage(msg); throw new Error(msg); }
             if (peerConnection) { log('debug',"Closing existing PC."); hangUpCall(false); }
             peerConnection = new RTCPeerConnection(rtcConfig); log('debug',"PC object created.");
             peerConnection.onicecandidate = (e) => { if (e.candidate && callRef && chatState === 'CHATTING') { log('debug', `Sending user ICE`); push(ref(db, `chats/${userId}/call/iceCandidates/user`), { ...e.candidate.toJSON(), sender: 'user' }); } };
             peerConnection.ontrack = (e) => { log('debug', `Remote track received`); if (e.streams && e.streams[0]) { remoteAudio.srcObject = e.streams[0]; remoteAudio.play().catch(err => log('error',"Remote audio play failed:", err)); } };
             peerConnection.onconnectionstatechange = () => { log('debug',`PC state: ${peerConnection?.connectionState}`); if (['disconnected', 'failed', 'closed'].includes(peerConnection?.connectionState) && chatState !== 'BLOCKED') { hangUpCall(false); } };
             try { log('debug',"Requesting mic..."); localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); log('info',"Mic access granted."); localAudio.srcObject = localStream; localStream.getTracks().forEach(track => { if (peerConnection) peerConnection.addTrack(track, localStream); }); log('debug',"Local tracks added."); }
             catch (error) {
                 log('error',"!!! Mic access error:", error.name, error.message); if(peerConnection) peerConnection.close(); peerConnection = null;
                 let userMessage = "Error: Could not access microphone.";
                 if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') { userMessage = "Error: Mic permission denied."; }
                 else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') { userMessage = "Error: No microphone found."; }
                 else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') { userMessage = "Error: Mic busy or hardware error."; }
                 else if (error.name === 'SecurityError') { userMessage = "Error: Mic requires HTTPS/localhost."; }
                 displayBotMessage(userMessage); callStatusDiv.textContent = userMessage; throw new Error(userMessage);
             }
        }

        // User Starts Call
        async function startUserCall() {
            if (!callRef || chatState !== 'CHATTING' || peerConnection) { log('warn',"Call start prevented."); return; }
            log('info', `User initiating call...`); callButton.disabled = true; callStatusDiv.textContent = 'Calling Admin...';
            try {
                await createPeerConnection(); if (!peerConnection) throw new Error("PC creation failed.");
                const offer = await peerConnection.createOffer(); await peerConnection.setLocalDescription(offer); log('debug',"User offer created.");
                const callData = { state: 'ringing', initiator: 'user', timestamp: serverTimestamp(), userName: userName, offer: { type: offer.type, sdp: offer.sdp }, answer: null, iceCandidates: null, endedBy: null };
                await remove(callRef); await set(callRef, callData); log('debug',"User call offer sent.");
                listenForAdminAnswer(); listenForAdminIceCandidates();
                // UI updated by handleCallStateChange listener reacting to 'ringing' state
            } catch (error) { log('error',"User call start error:", error.message); if (!error.message.startsWith("Error:")) { displayBotMessage(`Error starting call.`); callStatusDiv.textContent = 'Call failed'; } hangUpCall(false); callButton.textContent = 'Audio Call'; callButton.disabled = (chatState !== 'CHATTING'); }
        }

        // Listen for Admin's Answer (when user initiates)
        function listenForAdminAnswer() {
             if (!userId || !peerConnection) return; const answerRef = ref(db, `chats/${userId}/call/answer`); cleanupSpecificListener('answer'); callSignalListeners.answer = onValue(answerRef, async (s) => { const a = s.val(); if (a && peerConnection && peerConnection.signalingState === 'have-local-offer') { log('info', `Received answer from Admin`); try { await peerConnection.setRemoteDescription(new RTCSessionDescription(a)); log('debug',"Remote desc (answer) set."); /* State becomes active via ICE or call listener */ } catch (e) { log('error',`Set answer error:`, e); hangUpCall(true); } } }, (e) => { log('error',`Answer listener error:`, e); cleanupSpecificListener('answer'); }); log('debug',`Listening for admin answer`);
        }

        // Listen for Admin's ICE Candidates (when user initiates)
        function listenForAdminIceCandidates() {
             if (!userId || !peerConnection) return; const adminIceRef = ref(db, `chats/${userId}/call/iceCandidates/admin`); cleanupSpecificListener('ice'); callSignalListeners.ice = onChildAdded(adminIceRef, async (s) => { const c = s.val(); if (c && peerConnection && peerConnection.signalingState !== 'closed') { log('debug',`Received ICE from admin`); try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch (e) { if (!e.message.includes("remote description is not set") && !e.message.includes("closed")) { log('error', `Add ICE error:`, e); } } } }); log('debug',`Listening for admin ICE`);
        }

        // Handle Incoming Call Alert UI
        function showIncomingCallAlert(offerData) {
            if (!offerData) return; // Need offer to accept
            incomingCallAlert.dataset.offer = JSON.stringify(offerData); // Store offer data
            incomingCallAlert.style.display = 'block';
            callButton.disabled = true; // Disable main call button
            if (!isMuted) { /* Play ringtone? */ }
        }
        function hideIncomingCallAlert() {
            incomingCallAlert.style.display = 'none';
            incomingCallAlert.removeAttribute('data-offer');
            if (chatState === 'CHATTING' && !peerConnection) { // Re-enable main button if not in call
                 callButton.disabled = false;
            }
        }

        // User Accepts Call from Admin
        async function joinIncomingAdminCall() {
            log('info', "User accepting call from Admin...");
            const offerDataString = incomingCallAlert.dataset.offer;
            hideIncomingCallAlert(); // Hide alert immediately
            if (!offerDataString) { log('error', "Cannot accept call, offer data missing."); return; }
            const offerData = JSON.parse(offerDataString);

            callStatusDiv.textContent = 'Connecting...'; callButton.disabled = true;

            try {
                await createPeerConnection(); if (!peerConnection) throw new Error("PC creation failed.");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData)); log('debug',"Remote desc (admin offer) set.");
                const answer = await peerConnection.createAnswer(); await peerConnection.setLocalDescription(answer); log('debug',"User answer created.");
                const callUpdates = { state: 'active', answer: { type: answer.type, sdp: answer.sdp }, joinedBy: 'user', joinTimestamp: serverTimestamp() };
                await update(callRef, callUpdates); log('debug',"User answer sent, state set to active.");
                listenForAdminIceCandidates(); // Listen for admin's ICE
                // UI updated by handleCallStateChange listener reacting to 'active' state
            } catch (error) { log('error',"Error joining admin call:", error.message); displayBotMessage(`Error joining call.`); hangUpCall(true); callStatusDiv.textContent = 'Join failed'; callButton.textContent = 'Audio Call'; callButton.disabled = (chatState !== 'CHATTING'); }
        }

        // User Rejects Call from Admin
        function rejectIncomingAdminCall() {
            log('info', "User rejecting call from Admin...");
            hideIncomingCallAlert();
            if (callRef) { update(callRef, { state: 'ended', endedBy: 'user_rejected', endTimestamp: serverTimestamp() }).catch(e => log('error',"Error rejecting call:", e)); }
        }

        // Hang Up Call (User context)
        function hangUpCall(signalFirebase = true) {
             log('info', `Hanging up call. Signal: ${signalFirebase}`);
             hideIncomingCallAlert(); // Ensure alert is hidden
             if (peerConnection) { peerConnection.close(); peerConnection = null; }
             if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; localAudio.srcObject = null; }
             remoteAudio.srcObject = null; cleanupSignalListeners();
             if (signalFirebase && callRef && chatState !== 'BLOCKED') { update(callRef, { state: 'ended', endedBy: 'user', endTimestamp: serverTimestamp() }).catch(e => log('error',"Signal end failed:", e)); }
             // Reset UI (handled by updateCallUI reacting to 'ended' state)
             // Ensure button is re-enabled if appropriate
             if (chatState === 'CHATTING') {
                 callButton.textContent = 'Audio Call';
                 callButton.disabled = false;
                 callButton.onclick = handleCallButtonClick; // Re-attach main handler
                 callStatusDiv.textContent = 'Call Ended';
                 setTimeout(() => { if (!peerConnection) callStatusDiv.textContent = ''; }, 2500);
             }
        }

        // Update Call UI (User context)
        function updateCallUI(callState) {
             if (chatState === 'BLOCKED') return; // Don't update UI if blocked
             const state = callState?.state || 'idle';
             callButton.onclick = handleCallButtonClick; // Default handler

             switch (state) {
                 case 'ringing': // User is calling Admin
                     callStatusDiv.textContent = 'Calling Admin...';
                     callButton.textContent = 'Cancel Call';
                     callButton.disabled = false;
                     callButton.onclick = () => hangUpCall(true); // Change handler
                     break;
                 case 'admin-ringing': // Admin is calling User
                     callStatusDiv.textContent = 'Incoming call from Admin...'; // Status text
                     callButton.textContent = 'Audio Call'; // Main button text
                     callButton.disabled = true; // Disable main button while alert shows
                     // Alert handled by handleCallStateChange
                     break;
                 case 'active':
                     callStatusDiv.textContent = 'Call Active';
                     callButton.textContent = 'End Call';
                     callButton.disabled = false;
                     callButton.onclick = () => hangUpCall(true); // Change handler
                     hideIncomingCallAlert(); // Ensure alert is hidden
                     break;
                 case 'ended':
                     callStatusDiv.textContent = `Call Ended.`;
                     callButton.textContent = 'Audio Call';
                     callButton.disabled = false;
                     hideIncomingCallAlert();
                     if (peerConnection) hangUpCall(false); // Ensure local cleanup if ended externally
                     setTimeout(() => { if (!peerConnection) callStatusDiv.textContent = ''; }, 2500);
                     break;
                 case 'idle':
                 default:
                     callStatusDiv.textContent = '';
                     callButton.textContent = 'Audio Call';
                     callButton.disabled = false;
                     hideIncomingCallAlert();
                     if (peerConnection) hangUpCall(false); // Ensure cleanup if state becomes idle
                     break;
             }
        }

        // Central handler for the main call button
        function handleCallButtonClick() {
             if (chatState !== 'CHATTING') return;
             const currentCallState = callButton.textContent; // Use text as indicator for now

             if (currentCallState === 'Audio Call') {
                 startUserCall();
             } else if (currentCallState === 'Cancel Call' || currentCallState === 'End Call') {
                 hangUpCall(true); // User explicitly hangs up/cancels
             }
             // 'Join Call' is handled by the separate alert button
        }

        // Cleanup WebRTC Signal Listeners
        function cleanupSignalListeners() {
             log('debug', "Cleaning up signal listeners...");
             cleanupSpecificListener('answer');
             cleanupSpecificListener('ice');
        }
        function cleanupSpecificListener(type) { // type = 'answer' or 'ice'
             if (userId && callSignalListeners[type]) {
                 const path = type === 'answer' ? `chats/${userId}/call/answer` : `chats/${userId}/call/iceCandidates/admin`; // Listen for ADMIN candidates
                 const event = type === 'answer' ? 'value' : 'child_added';
                 try { off(ref(db, path), event, callSignalListeners[type]); } catch(e){log('warn',`Error cleaning ${type} listener:`, e)}
                 callSignalListeners[type] = null;
                 log('debug', `Cleaned ${type} listener`);
             }
        }

        // --- Notifications ---
        function requestNotificationPermission() { if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') { Notification.requestPermission(); } }
        function showNotification(message) { if (!('Notification' in window) || Notification.permission !== 'granted' || !document.hidden) { return; } new Notification('Chat Support', { body: message }); }

        // --- General Cleanup ---
        function cleanupListeners() {
             log('info', "Cleaning up Firebase listeners...");
             if (globalListeners.messages) off(messagesRef, 'child_added', globalListeners.messages);
             if (globalListeners.adminStatus) off(adminOnlineRef, 'value', globalListeners.adminStatus);
             if (globalListeners.adminTyping) off(adminTypingRef, 'value', globalListeners.adminTyping);
             if (globalListeners.call) off(callRef, 'value', globalListeners.call);
             if (globalListeners.connected) off(connectedRef, 'value', globalListeners.connected);
             if (globalListeners.block) off(ref(db, `chats/${userId}/metadata/isBlocked`), 'value', globalListeners.block);
             cleanupSignalListeners();
             globalListeners = {}; // Reset global listener store
         }
         window.addEventListener('beforeunload', () => { if (peerConnection) { hangUpCall(true); } cleanupListeners(); });

        // --- Utility Functions ---
        function formatTimestamp(timestamp) { if (!timestamp) return ''; try { return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); } catch (e) { return ''; } }

        // --- Run App ---
        initApp();

    </script>
</body>
</html>